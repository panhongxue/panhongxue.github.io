<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>图片相似度对比</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"
    />
    <style>
      [v-cloak] {
        display: none;
      }
      #app {
        /* min-width: 800px; */
        /* max-width: 1300px; */
        width: 1200px;
        margin: auto;
      }
      .flex {
        display: flex;
      }
      .flex > div {
        width: 50%;
        /* border: 1px solid #000; */
        margin: 0 10px;
        position: relative;
      }
      .el-upload-dragger {
        width: 580px;
        height: 326px;
      }
      .upload-button-wrap {
        display: flex;
        flex-direction: column;
        justify-content: center;
        height: 100%;
      }
      .el-upload-dragger .el-icon-upload {
        margin-top: 0;
      }

      h3 {
        text-align: center;
      }
      label {
        line-height: 38px;
      }
      .image-slot {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
        background: #f5f7fa;
        font-size: 30px;
        color: #909399;
      }
      span {
        font-weight: bold;
      }

      .hue {
        background-image: url(https://panhongxue.github.io/files/img/hue.png);
        background-repeat: no-repeat;
        background-size: 100%;
        width: 400px;
        height: 333px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }
      .hue em {
        position: absolute;
        margin: 3px 0 0 3px;
        /* border-radius: 50%; */
        width: 276px;
        height: 276px;
        /* transform: rotate(45deg); */
      }
      .hue i {
        display: block;
        margin: auto;
        width: 4px;
        height: 50%;
        border-radius: 2px;
        background-color: #0052d9;
      }
      #color_log i {
        float: left;
        width: 1px;
        height: 1px;
      }
    </style>
  </head>
  <body>
    <div id="app" v-cloak>
      <div class="flex">
        <div>
          <el-upload
            drag
            multiple
            action="http://localhost:3601/x-tiny"
            accept="image/*"
            :auto-upload="false"
            :show-file-list="false"
            :on-change="onUploaderChange1"
          >
            <el-image
              v-if="imageUrl1"
              :src="imageUrl1"
              fit="contain"
              style="width: 100%; height: 100%"
            ></el-image>
            <div v-else class="upload-button-wrap">
              <i class="el-icon-upload"></i>
              <div class="el-upload__text">
                将文件拖到此处，或<em>点击上传</em>
              </div>
            </div>
          </el-upload>
          <div class="info">
            <p>文件名：<span>{{file1.name}}</span></p>
            <p>格式：<span>{{file1.type}}</span></p>
            <p>分辨率：<span>{{imageWH1}}</span></p>
            <p>大小：<span>{{prettyBytes(file1.size)}}</span></p>
            <p>品质：<span>{{image1Quality}}</span></p>
            <p>相似度：<span :style="{color:ssimColor}">{{imgSSIM}}</span></p>
            <div class="hue">
              <em
                v-for="hsl in colors"
                :style="{width:(40+2*(1-hsl.l)*236)+'px', height:2*(40+(1-hsl.l)*236)+'px', transform:`rotate(${hsl.h*360}deg)`}"
              >
                <i
                  :style="{width:hsl.ratio+'px', backgroundColor:`rgba(${255-hsl.r},${255-hsl.g},${255-hsl.b},0.75)`}"
                ></i>
              </em>
            </div>
            <div id="color_log"></div>
          </div>
        </div>
        <div>
          <el-upload
            drag
            multiple
            action="http://localhost:3601/x-tiny"
            accept="image/*"
            :auto-upload="false"
            :show-file-list="false"
            :on-change="onUploaderChange2"
          >
            <el-image
              v-if="imageUrl2"
              :src="imageUrl2"
              fit="contain"
              style="width: 100%; height: 100%"
            ></el-image>
            <div v-else class="upload-button-wrap">
              <i class="el-icon-upload"></i>
              <div class="el-upload__text">
                将文件拖到此处，或<em>点击上传</em>
              </div>
            </div>
          </el-upload>
          <div class="info">
            <p>文件名：<span>{{file2.name}}</span></p>
            <p>格式：<span>{{file2.type}}</span></p>
            <p>分辨率：<span>{{imageWH2}}</span></p>
            <p>大小：<span>{{prettyBytes(file2.size)}}</span></p>
            <p>品质：<span>{{image2Quality}}</span></p>
          </div>
        </div>
      </div>
    </div>
  </body>
  <script src="https://unpkg.com/vue@2"></script>
  <script src="https://unpkg.com/element-ui"></script>
  <script src="https://unpkg.com/ssim.js"></script>
  <script src="https://s0.qhres2.com/!fac91dc5/pretty-bytes.js"></script>
  <script>
    function log() {}
    function write() {}
    function printf(format, d) {}
    function buf2hex(uint8Array) {
      return Array.prototype.map
        .call(uint8Array, (v) => v.toString(16).padStart(2, '0'))
        .join('');
    }

    function jpegquality(buf) {
      // validate jpeg header
      if (buf[0] !== 255 && buf[1] !== 216)
        throw new Error('Not a supported JPEG format');

      var diff;
      var quality;

      var tables = searchQuantizationTable(buf);
      var avgs = tables.map((table, index) => averageTable(table, index));

      if (avgs.length > 3) avgs.length = 3;

      if (avgs.length === 1) {
        log('only one table result is', avgs[0]);
        return avgs[0];
      }

      if (avgs.length === 2) {
        avgs[2] = avgs[1];
        diff = Math.abs(avgs[0] - avgs[1]) * 0.49;
        diff += Math.abs(avgs[0] - avgs[2]) * 0.49;
        quality = (avgs[0] + avgs[1] + avgs[2]) / 3 + diff;
        log('%' + quality);
        return quality;
      }

      if (avgs.length === 3) {
        diff = Math.abs(avgs[0] - avgs[1]) * 0.49;
        diff += Math.abs(avgs[0] - avgs[2]) * 0.49;
        quality = (avgs[0] + avgs[1] + avgs[2]) / 3 + diff;
        log('%' + quality);
        return quality;
      }
    }
    function averageTable(table, index) {
      var arr = [];
      var total = 0;

      log('Quantization table', index ? '(chrominance)' : '(luminance)');

      for (var i = 0; i < table.length; i += 2) {
        arr.push(table[i] + table[i + 1]);
      }

      arr.unshift();

      for (var j = 0; j < arr.length; j += 1) {
        var d = parseInt(arr[j], 16);
        if (j % 8 === 0) write('\n');
        printf('%4d', d);
        if (j !== 0) total += d;
      }
      write('\n');
      var result = 100.0 - total / 63;
      log('result = %' + result);
      return result;
    }
    function searchQuantizationTable(buf) {
      var length = 0;
      var arr = [];
      var B1;
      var B2;
      var type;
      var i = 2;
      while (i < buf.length) {
        if (buf[i] === 0xff) {
          B1 = buf[i];
          i += 1;
          while (buf[i] === 255) {
            i += 1;
          }
          if (buf[i] === 0) continue;
          B2 = buf[i];
          i += 1;
          type = B1 * 256 + B2;
          length = buf[i] * 256 + buf[i + 1] - 2;
          i += 2;

          if (type !== 0xffdb) {
            i += length;
            continue;
          }

          if (length % 65 === 0) {
            var table = buf.slice(i, i + length);
            for (var j = 0; j < length / 65; j += 1) {
              arr.push(buf2hex(table.slice(j * 65, (j + 1) * 65)));
            }
            i += length;
          }
        } else {
          i += 1;
        }
      }
      return arr;
    }

    function rgbToHsl(r, g, b, log) {
      (r /= 255), (g /= 255), (b /= 255);
      var max = Math.max(r, g, b),
        min = Math.min(r, g, b);
      var h,
        s,
        l = (max + min) / 2;

      if (max == min) {
        h = s = 0; // achromatic
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      const ret = { h, s, l };
      log && console.log(ret);

      return ret;
    }
    function hslToRgb(h, s, l) {
      var r, g, b;

      if (s == 0) {
        r = g = b = l; // achromatic
      } else {
        var hue2rgb = function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };

        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }

      return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255),
      };
    }

    async function getImageData(imgUrl) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          let canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.width = img.width;
          canvas.height = img.height;
          context.drawImage(img, 0, 0);
          const imgData = context.getImageData(0, 0, img.width, img.height);
          resolve({
            width: img.width,
            height: img.height,
            imgData,
          });
        };
        img.src = imgUrl;
      });
    }

    let files = [],
      lastOnChangeTime = Date.now(),
      img1Data,
      img2Data,
      timer;

    new Vue({
      el: '#app',
      data: function () {
        return {
          file1: { imageWH: '' },
          file2: { imageWH: '' },
          imageUrl1: '',
          imageUrl2: '',
          imageWH1: '',
          imageWH2: '',
          image1Quality: '',
          image2Quality: '',
          ssimColor: '',
          imgSSIM: '',
          // hsl: rgbToHsl(255, 0, 0, true),
          colors: [],
        };
      },
      computed: {},
      methods: {
        prettyBytes(size) {
          return size && prettyBytes(size, { binary: true });
        },
        onUploaderChange1(file) {
          this.onUploaderChange(file, 1);
        },
        onUploaderChange2(file) {
          this.onUploaderChange(file, 2);
        },
        onUploaderChange({ raw }, target) {
          const interval = Date.now() - lastOnChangeTime;
          lastOnChangeTime = Date.now();
          if (interval > 100) {
            files = [];
          }
          files.push(raw);

          clearInterval(timer);
          timer = setTimeout(() => {
            this.processImgs(target);
          }, 100);
        },

        async processImgs(target) {
          this.imgSSIM = '---';

          this[`file${target}`] = files[0];
          await this.createBlobURL(target);
          this.readQuality(files[0], `image${target}Quality`);
          if (files[1]) {
            const other = target == 1 ? 2 : 1;
            this[`file${other}`] = files[1];
            await this.createBlobURL(other);
            this.readQuality(files[1], `image${other}Quality`);
          }

          this.$nextTick(() => {
            setTimeout(() => {
              this.calcSSIM();
            }, 50);
          });
        },

        async createBlobURL(target) {
          URL.revokeObjectURL(this[`imageUrl${target}`]);
          this[`imageUrl${target}`] = URL.createObjectURL(
            this[`file${target}`]
          );

          const imgData = await getImageData(this[`imageUrl${target}`]);
          Object.assign(this[`file${target}`], imgData);
          this[`imageWH${target}`] = imgData.width + ' x ' + imgData.height;

          this.calcImageFeatures(target);
        },

        calcImageFeatures(target) {
          const imgData = this[`file${target}`].imgData;
          // console.log(imgData);
          this.colors = this.calcAveHsl(imgData);
        },

        logColor(r, g, b) {
          const ele = document.createElement('i');
          ele.style.backgroundColor = `rgb(${[r, g, b].join(',')})`;
          color_log.appendChild(ele);
        },

        calcAveHsl(imgData) {
          var blockSize = 8; // 每隔x像素计算1次
          var pixelCount = 0;
          var r, g, b;
          const huv = {};
          const huvMap = [
            '红色',
            '橙色',
            '黄色',
            '黄绿色',
            '绿色',
            '蓝绿色',
            '青色',
            '蓝色',
            '蓝紫色',
            '紫色',
            '粉紫色',
            '品红',
          ];
          const grid = 1 / 12;
          const { data } = imgData;
          for (var i = 0; i < data.length; ) {
            if (data[i + 3] == 0) {
              r = g = b = 255;
            } else {
              r = data[i];
              g = data[i + 1];
              b = data[i + 2];
            }
            const hsl = rgbToHsl(r, g, b);
            if (hsl.s > 0.4 && hsl.l > 0.3 && hsl.l < 0.7) {
              let h = hsl.h + grid / 2;
              h = h >= 1 ? h - 1 : h;
              const idx = Math.floor(h / grid);
              huv[idx] = huv[idx] || { h: [], s: [], l: [] };
              huv[idx].h.push(h);
              huv[idx].s.push(hsl.s);
              huv[idx].l.push(hsl.l);

              // if (idx == 2) {
              //   this.logColor(r, g, b);
              // }
            }
            pixelCount++;

            i += 4 * blockSize;
          }

          let colors = Object.keys(huv).map((idx) => {
            const hsl = {
              index: Number(idx),
              color: huvMap[Number(idx)],
              ratio: Math.ceil((huv[idx].h.length / pixelCount) * 1000) / 10,
              count: huv[idx].h.length,
              h:
                huv[idx].h.reduce((n, m) => n + m) / huv[idx].h.length -
                grid / 2,
              s: huv[idx].s.reduce((n, m) => n + m) / huv[idx].s.length,
              l: huv[idx].l.reduce((n, m) => n + m) / huv[idx].l.length,
            };
            return Object.assign(hsl, hslToRgb(hsl.h, hsl.s, 0.5));
          });
          console.log(colors);

          colors = colors.filter((item) => item.ratio >= 1);
          console.log('过滤1%', colors);

          return JSON.parse(JSON.stringify(colors));
        },

        calcSSIM() {
          if (this.file1.imgData && this.file2.imgData) {
            try {
              const ssimRet = ssim.ssim(this.file1.imgData, this.file2.imgData);
              this.ssimColor = ssimRet.mssim >= 0.998 ? '#67C23A' : '#F56C6C';
              this.imgSSIM = (ssimRet.mssim * 100).toFixed(4) + '%';
            } catch (ex) {
              this.$message.error(ex);
            }
          }
        },

        readQuality(file, dataName) {
          const reader = new FileReader();
          reader.onload = (e) => {
            this[dataName] = '';
            try {
              this[dataName] = jpegquality(
                new Uint8Array(e.target.result)
              ).toFixed(1);
            } catch {}
          };
          reader.readAsArrayBuffer(file);
        },
      },
    });
  </script>
</html>
